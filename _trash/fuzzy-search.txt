function useSymbolSearch(symbolsData, searchTerm, selectedCategory) {
  const [isLoading, setIsLoading] = useState(false);
  const [searchResults, setSearchResults] = useState([]);
  const [numResults, setNumResults] = useState(0);
  const [numSymbols, setNumSymbols] = useState(0);

  useEffect(() => {
    if (!symbolsData) return;
    setIsLoading(true);

    const maxDistance = 3; // adjust this value to control the fuzziness of the search

    const results = symbolsData.categories.category.flatMap((category) => {
      if (selectedCategory && selectedCategory !== category.title) {
        return [];
      }
      const categoryResults = category.symbols.filter((symbol) => {
        const symbolName =
          typeof symbol.name === "string" ? symbol.name.replace(/\s+/g, "") : "";
        const symbolWords = symbolName.split(/(?=[A-Z])/);
        const matchDistances = symbolWords.map((word) =>
          levenshteinDistance(searchTerm, word)
        );
        const minDistance = Math.min(...matchDistances);
        const symbolRegex = new RegExp(
          searchTerm.split(/\s+/).map((word) => escapeRegExp(word)).join("|"),
          "i"
        );
        const matchesRegex = symbolRegex.test(symbolName);
        return minDistance <= maxDistance || matchesRegex;
      });
      return categoryResults.map((result) => ({ category, symbol: result }));
    });

    const filteredResults = results.filter((result) => {
      if (selectedCategory) {
        return result.category.title === selectedCategory;
      }
      return true;
    });

    const numResults = filteredResults.length;
    const numSymbols = symbolsData.categories.category.reduce(
      (acc, category) => acc + category.symbols.length,
      0
    );

    setSearchResults(filteredResults);
    setNumResults(numResults);
    setNumSymbols(numSymbols);
    setIsLoading(false);
  }, [symbolsData, searchTerm, selectedCategory]);

  return { isLoading, searchResults, numResults, numSymbols };
}

function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function levenshteinDistance(s1, s2) {
  const m = s1.length;
  const n = s2.length;
  const d = [];

  for (let i = 0; i <= m; i++) {
    d[i] = [i];
  }
  for (let j = 0; j <= n; j++) {
    d[0][j] = j;
  }

  for (let j = 1; j <= n; j++) {
    for (let i = 1; i <= m; i++) {
      if (s1[i - 1] === s2[j - 1]) {
        d[i][j] = d[i - 1][j - 1];
      } else {
        d[i][j] =
          Math.min(d[i - 1][j], d[i][j - 1], d[i - 1][j - 1]) + 1;
      }
    }
  }

  return d[m][n];
}
